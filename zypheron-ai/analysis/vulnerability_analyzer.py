"""
Vulnerability Analysis Engine
Analyzes scan results and enriches with CVE data
"""

from typing import List, Dict, Any, Optional
from dataclasses import dataclass
import re
from loguru import logger
import asyncio

try:
    import nvdlib
    NVD_AVAILABLE = True
except ImportError:
    NVD_AVAILABLE = False
    logger.warning("nvdlib not available - CVE enrichment disabled")

from providers.manager import ai_manager
from providers.base import AIMessage
from core.config import config


@dataclass
class Vulnerability:
    """Vulnerability data structure"""
    id: str
    title: str
    description: str
    severity: str  # critical, high, medium, low, info
    cvss_score: Optional[float] = None
    cve_id: Optional[str] = None
    affected_service: Optional[str] = None
    port: Optional[int] = None
    host: Optional[str] = None
    remediation: Optional[str] = None
    exploit_available: bool = False
    references: List[str] = None
    
    def __post_init__(self):
        if self.references is None:
            self.references = []


class VulnerabilityAnalyzer:
    """Analyzes security scan results and identifies vulnerabilities"""
    
    def __init__(self):
        self.cve_cache = {}
        self.nvd_api_key = config.NVD_API_KEY
    
    async def analyze_scan_output(
        self,
        scan_output: str,
        tool: str,
        target: str,
        use_ai: bool = True
    ) -> List[Vulnerability]:
        """
        Analyze scan output and extract vulnerabilities
        
        Args:
            scan_output: Raw output from security scanning tool
            tool: Name of the tool used (nmap, nikto, etc.)
            target: Target host/network
            use_ai: Whether to use AI for analysis
        
        Returns:
            List of identified vulnerabilities
        """
        logger.info(f"Analyzing {tool} scan results for {target}")
        
        # Parse tool-specific output
        vulns = []
        
        if tool.lower() == "nmap":
            vulns = self._parse_nmap_output(scan_output, target)
        elif tool.lower() == "nikto":
            vulns = self._parse_nikto_output(scan_output, target)
        elif tool.lower() in ["sqlmap", "wpscan", "gobuster"]:
            vulns = self._parse_generic_output(scan_output, tool, target)
        else:
            vulns = self._parse_generic_output(scan_output, tool, target)
        
        # Enrich with CVE data
        for vuln in vulns:
            if vuln.cve_id:
                await self._enrich_with_cve_data(vuln)
        
        # Use AI for deeper analysis
        if use_ai and vulns:
            vulns = await self._ai_analyze_vulnerabilities(vulns, scan_output)
        
        return vulns
    
    def _parse_nmap_output(self, output: str, target: str) -> List[Vulnerability]:
        """Parse Nmap output for vulnerabilities"""
        vulns = []
        
        # Look for open ports with service versions
        port_pattern = r'(\d+)/(\w+)\s+open\s+(\w+)\s+(.+)'
        for match in re.finditer(port_pattern, output):
            port, protocol, service, version = match.groups()
            
            # Check for potentially vulnerable services
            if any(vuln_svc in service.lower() for vuln_svc in ['ftp', 'telnet', 'smb', 'mysql', 'postgresql']):
                vulns.append(Vulnerability(
                    id=f"nmap-{target}-{port}",
                    title=f"Potentially insecure service: {service}",
                    description=f"Found {service} running on port {port} ({protocol}): {version}",
                    severity="medium",
                    affected_service=service,
                    port=int(port),
                    host=target,
                ))
        
        # Look for NSE script results (vulnerability scans)
        if "VULNERABLE" in output:
            vuln_sections = re.split(r'\n(?=\d+/\w+)', output)
            for section in vuln_sections:
                if "VULNERABLE" in section:
                    # Extract CVE if present
                    cve_match = re.search(r'(CVE-\d{4}-\d+)', section)
                    cve_id = cve_match.group(1) if cve_match else None
                    
                    vulns.append(Vulnerability(
                        id=f"nmap-vuln-{len(vulns)}",
                        title="NSE Vulnerability Detected",
                        description=section[:200],
                        severity="high",
                        cve_id=cve_id,
                        host=target,
                    ))
        
        return vulns
    
    def _parse_nikto_output(self, output: str, target: str) -> List[Vulnerability]:
        """Parse Nikto output for web vulnerabilities"""
        vulns = []
        
        # Nikto outputs findings with + prefix
        finding_pattern = r'\+ (.+)'
        for match in re.finditer(finding_pattern, output):
            finding = match.group(1)
            
            # Determine severity based on keywords
            severity = "info"
            if any(kw in finding.lower() for kw in ['vulnerability', 'exploit', 'xss', 'sql injection']):
                severity = "high"
            elif any(kw in finding.lower() for kw in ['outdated', 'default', 'sensitive']):
                severity = "medium"
            
            # Extract OSVDB reference if present
            osvdb_match = re.search(r'OSVDB-(\d+)', finding)
            refs = [f"OSVDB-{osvdb_match.group(1)}"] if osvdb_match else []
            
            vulns.append(Vulnerability(
                id=f"nikto-{len(vulns)}",
                title="Web Vulnerability",
                description=finding,
                severity=severity,
                affected_service="http",
                host=target,
                references=refs,
            ))
        
        return vulns
    
    def _parse_generic_output(self, output: str, tool: str, target: str) -> List[Vulnerability]:
        """Parse generic tool output"""
        vulns = []
        
        # Look for common vulnerability indicators
        vuln_keywords = {
            'critical': ['critical', 'severe', 'remote code execution', 'rce'],
            'high': ['high', 'vulnerability', 'exploit', 'sql injection', 'xss'],
            'medium': ['medium', 'misconfiguration', 'information disclosure'],
            'low': ['low', 'warning'],
        }
        
        lines = output.split('\n')
        for i, line in enumerate(lines):
            for severity, keywords in vuln_keywords.items():
                if any(kw in line.lower() for kw in keywords):
                    # Extract CVE if present
                    cve_match = re.search(r'(CVE-\d{4}-\d+)', line)
                    cve_id = cve_match.group(1) if cve_match else None
                    
                    vulns.append(Vulnerability(
                        id=f"{tool}-{i}",
                        title=f"{tool.upper()} Finding",
                        description=line.strip(),
                        severity=severity,
                        cve_id=cve_id,
                        host=target,
                    ))
                    break
        
        return vulns
    
    async def _enrich_with_cve_data(self, vuln: Vulnerability):
        """Enrich vulnerability with CVE database data"""
        if not vuln.cve_id or not NVD_AVAILABLE:
            return
        
        # Check cache first
        if vuln.cve_id in self.cve_cache:
            cve_data = self.cve_cache[vuln.cve_id]
        else:
            try:
                # Fetch from NVD
                cve_data = nvdlib.searchCVE(cveId=vuln.cve_id, key=self.nvd_api_key)[0]
                self.cve_cache[vuln.cve_id] = cve_data
            except Exception as e:
                logger.debug(f"Failed to fetch CVE {vuln.cve_id}: {e}")
                return
        
        # Enrich vulnerability with CVE data
        if hasattr(cve_data, 'v31score'):
            vuln.cvss_score = cve_data.v31score
        elif hasattr(cve_data, 'v2score'):
            vuln.cvss_score = cve_data.v2score
        
        if hasattr(cve_data, 'descriptions'):
            vuln.description = cve_data.descriptions[0].value if cve_data.descriptions else vuln.description
    
    async def _ai_analyze_vulnerabilities(
        self,
        vulns: List[Vulnerability],
        scan_output: str
    ) -> List[Vulnerability]:
        """Use AI to provide deeper analysis and context"""
        
        try:
            # Prepare context for AI
            vuln_summary = "\n".join([
                f"- {v.severity.upper()}: {v.title} ({v.description[:100]}...)"
                for v in vulns[:10]  # Limit to top 10 for token efficiency
            ])
            
            messages = [
                AIMessage(
                    role="system",
                    content="You are a cybersecurity expert analyzing vulnerability scan results. Provide actionable insights and prioritize findings."
                ),
                AIMessage(
                    role="user",
                    content=f"""Analyze these vulnerability findings:

{vuln_summary}

Raw scan output (excerpt):
{scan_output[:1000]}

For each critical and high severity finding:
1. Assess the actual risk
2. Suggest specific remediation steps
3. Identify potential attack paths
4. Flag if exploit code is likely available

Format as JSON list."""
                )
            ]
            
            # Get AI analysis
            response = await ai_manager.chat(messages=messages, temperature=0.3)
            
            # Parse AI response and enhance vulnerabilities
            # (In production, you'd parse the JSON and update vulns)
            logger.info(f"AI Analysis: {response.content[:200]}...")
            
            # For now, just add AI insights as metadata
            for vuln in vulns:
                if not vuln.remediation and vuln.severity in ['critical', 'high']:
                    vuln.remediation = "See AI analysis for detailed remediation steps"
        
        except Exception as e:
            logger.error(f"AI analysis failed: {e}")
        
        return vulns
    
    def prioritize_vulnerabilities(self, vulns: List[Vulnerability]) -> List[Vulnerability]:
        """Prioritize vulnerabilities by severity and exploitability"""
        severity_order = {
            'critical': 0,
            'high': 1,
            'medium': 2,
            'low': 3,
            'info': 4,
        }
        
        return sorted(vulns, key=lambda v: (
            severity_order.get(v.severity, 99),
            -1 if v.exploit_available else 0,
            -v.cvss_score if v.cvss_score else 0,
        ))
    
    async def generate_report(
        self,
        vulns: List[Vulnerability],
        format: str = "text"
    ) -> str:
        """Generate a vulnerability report"""
        
        if format == "text":
            lines = ["=" * 60, "VULNERABILITY REPORT", "=" * 60, ""]
            
            prioritized = self.prioritize_vulnerabilities(vulns)
            
            severity_counts = {}
            for v in prioritized:
                severity_counts[v.severity] = severity_counts.get(v.severity, 0) + 1
            
            lines.append("SUMMARY:")
            for severity in ['critical', 'high', 'medium', 'low', 'info']:
                count = severity_counts.get(severity, 0)
                if count > 0:
                    lines.append(f"  {severity.upper()}: {count}")
            lines.append("")
            
            lines.append("DETAILED FINDINGS:")
            lines.append("")
            
            for vuln in prioritized:
                lines.append(f"[{vuln.severity.upper()}] {vuln.title}")
                lines.append(f"  ID: {vuln.id}")
                if vuln.cve_id:
                    lines.append(f"  CVE: {vuln.cve_id}")
                if vuln.cvss_score:
                    lines.append(f"  CVSS: {vuln.cvss_score}")
                lines.append(f"  Description: {vuln.description}")
                if vuln.remediation:
                    lines.append(f"  Remediation: {vuln.remediation}")
                lines.append("")
            
            return "\n".join(lines)
        
        elif format == "json":
            import json
            return json.dumps([{
                'id': v.id,
                'title': v.title,
                'description': v.description,
                'severity': v.severity,
                'cvss_score': v.cvss_score,
                'cve_id': v.cve_id,
                'host': v.host,
                'port': v.port,
                'remediation': v.remediation,
                'exploit_available': v.exploit_available,
                'references': v.references,
            } for v in vulns], indent=2)
        
        else:
            raise ValueError(f"Unsupported format: {format}")

