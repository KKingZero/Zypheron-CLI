"""
Vulnerability Analysis Engine
Analyzes scan results and enriches with CVE data
"""

import json
import re
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

import asyncio
from loguru import logger

try:
    import nvdlib
    NVD_AVAILABLE = True
except ImportError:
    NVD_AVAILABLE = False
    logger.warning("nvdlib not available - CVE enrichment disabled")

from providers.manager import ai_manager
from providers.base import AIMessage
from core.config import config


@dataclass
class Vulnerability:
    """Vulnerability data structure"""
    id: str
    title: str
    description: str
    severity: str  # critical, high, medium, low, info
    cvss_score: Optional[float] = None
    cve_id: Optional[str] = None
    affected_service: Optional[str] = None
    port: Optional[int] = None
    host: Optional[str] = None
    remediation: Optional[str] = None
    exploit_available: bool = False
    references: List[str] = None
    confidence: float = 0.5
    evidence: List[str] = None
    attack_paths: List[str] = None
    tool_sources: List[str] = None
    ai_annotations: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.references is None:
            self.references = []
        if self.evidence is None:
            self.evidence = []
        if self.attack_paths is None:
            self.attack_paths = []
        if self.tool_sources is None:
            self.tool_sources = []
        if self.ai_annotations is None:
            self.ai_annotations = {}


class VulnerabilityAnalyzer:
    """Analyzes security scan results and identifies vulnerabilities"""
    
    def __init__(self):
        self.cve_cache = {}
        self.nvd_api_key = config.NVD_API_KEY
    
    async def analyze_scan_output(
        self,
        scan_output: str,
        tool: str,
        target: str,
        use_ai: bool = True
    ) -> List[Vulnerability]:
        """
        Analyze scan output and extract vulnerabilities
        
        Args:
            scan_output: Raw output from security scanning tool
            tool: Name of the tool used (nmap, nikto, etc.)
            target: Target host/network
            use_ai: Whether to use AI for analysis
        
        Returns:
            List of identified vulnerabilities
        """
        logger.info(f"Analyzing {tool} scan results for {target}")
        
        # Parse tool-specific output
        vulns = []
        
        if tool.lower() == "nmap":
            vulns = self._parse_nmap_output(scan_output, target)
        elif tool.lower() == "nikto":
            vulns = self._parse_nikto_output(scan_output, target)
        elif tool.lower() in ["sqlmap", "wpscan", "gobuster"]:
            vulns = self._parse_generic_output(scan_output, tool, target)
        else:
            vulns = self._parse_generic_output(scan_output, tool, target)
        
        for vuln in vulns:
            if tool.lower() not in vuln.tool_sources:
                vuln.tool_sources.append(tool.lower())

        # Enrich with CVE data
        for vuln in vulns:
            if vuln.cve_id:
                await self._enrich_with_cve_data(vuln)
            self._apply_confidence_heuristics(vuln)

        vulns = self._correlate_vulnerabilities(vulns)

        # Use AI for deeper analysis
        if use_ai and vulns:
            vulns = await self._ai_analyze_vulnerabilities(vulns, scan_output)
        
        return vulns
    
    def _parse_nmap_output(self, output: str, target: str) -> List[Vulnerability]:
        """Parse Nmap output for vulnerabilities"""
        vulns = []
        
        # Look for open ports with service versions
        port_pattern = r'(\d+)/(\w+)\s+open\s+(\w+)\s+(.+)'
        for match in re.finditer(port_pattern, output):
            port, protocol, service, version = match.groups()
            
            # Check for potentially vulnerable services
            if any(vuln_svc in service.lower() for vuln_svc in ['ftp', 'telnet', 'smb', 'mysql', 'postgresql']):
                vulns.append(Vulnerability(
                    id=f"nmap-{target}-{port}",
                    title=f"Potentially insecure service: {service}",
                    description=f"Found {service} running on port {port} ({protocol}): {version}",
                    severity="medium",
                    affected_service=service,
                    port=int(port),
                    host=target,
                    tool_sources=["nmap"],
                    evidence=[f"{service} on port {port}/{protocol} version {version}"]
                ))
        
        # Look for NSE script results (vulnerability scans)
        if "VULNERABLE" in output:
            vuln_sections = re.split(r'\n(?=\d+/\w+)', output)
            for section in vuln_sections:
                if "VULNERABLE" in section:
                    # Extract CVE if present
                    cve_match = re.search(r'(CVE-\d{4}-\d+)', section)
                    cve_id = cve_match.group(1) if cve_match else None
                    
                    vulns.append(Vulnerability(
                        id=f"nmap-vuln-{len(vulns)}",
                        title="NSE Vulnerability Detected",
                        description=section[:200],
                        severity="high",
                        cve_id=cve_id,
                        host=target,
                        tool_sources=["nmap"],
                        evidence=[section[:400]]
                    ))
        
        return vulns
    
    def _parse_nikto_output(self, output: str, target: str) -> List[Vulnerability]:
        """Parse Nikto output for web vulnerabilities"""
        vulns = []
        
        # Nikto outputs findings with + prefix
        finding_pattern = r'\+ (.+)'
        for match in re.finditer(finding_pattern, output):
            finding = match.group(1)
            
            # Determine severity based on keywords
            severity = "info"
            if any(kw in finding.lower() for kw in ['vulnerability', 'exploit', 'xss', 'sql injection']):
                severity = "high"
            elif any(kw in finding.lower() for kw in ['outdated', 'default', 'sensitive']):
                severity = "medium"
            
            # Extract OSVDB reference if present
            osvdb_match = re.search(r'OSVDB-(\d+)', finding)
            refs = [f"OSVDB-{osvdb_match.group(1)}"] if osvdb_match else []
            
            vulns.append(Vulnerability(
                id=f"nikto-{len(vulns)}",
                title="Web Vulnerability",
                description=finding,
                severity=severity,
                affected_service="http",
                host=target,
                references=refs,
                tool_sources=["nikto"],
                evidence=[finding]
            ))
        
        return vulns
    
    def _parse_generic_output(self, output: str, tool: str, target: str) -> List[Vulnerability]:
        """Parse generic tool output"""
        vulns = []
        
        # Look for common vulnerability indicators
        vuln_keywords = {
            'critical': ['critical', 'severe', 'remote code execution', 'rce'],
            'high': ['high', 'vulnerability', 'exploit', 'sql injection', 'xss'],
            'medium': ['medium', 'misconfiguration', 'information disclosure'],
            'low': ['low', 'warning'],
        }
        
        lines = output.split('\n')
        for i, line in enumerate(lines):
            for severity, keywords in vuln_keywords.items():
                if any(kw in line.lower() for kw in keywords):
                    # Extract CVE if present
                    cve_match = re.search(r'(CVE-\d{4}-\d+)', line)
                    cve_id = cve_match.group(1) if cve_match else None
                    
                    vulns.append(Vulnerability(
                        id=f"{tool}-{i}",
                        title=f"{tool.upper()} Finding",
                        description=line.strip(),
                        severity=severity,
                        cve_id=cve_id,
                        host=target,
                        tool_sources=[tool.lower()],
                        evidence=[line.strip()]
                    ))
                    break
        
        return vulns
    
    async def _enrich_with_cve_data(self, vuln: Vulnerability):
        """Enrich vulnerability with CVE database data"""
        if not vuln.cve_id or not NVD_AVAILABLE:
            return
        
        # Check cache first
        if vuln.cve_id in self.cve_cache:
            cve_data = self.cve_cache[vuln.cve_id]
        else:
            try:
                # Fetch from NVD
                cve_data = nvdlib.searchCVE(cveId=vuln.cve_id, key=self.nvd_api_key)[0]
                self.cve_cache[vuln.cve_id] = cve_data
            except Exception as e:
                logger.debug(f"Failed to fetch CVE {vuln.cve_id}: {e}")
                return
        
        # Enrich vulnerability with CVE data
        if hasattr(cve_data, 'v31score'):
            vuln.cvss_score = cve_data.v31score
        elif hasattr(cve_data, 'v2score'):
            vuln.cvss_score = cve_data.v2score
        
        if hasattr(cve_data, 'descriptions'):
            vuln.description = cve_data.descriptions[0].value if cve_data.descriptions else vuln.description
        self._apply_confidence_heuristics(vuln)

    def _apply_confidence_heuristics(self, vuln: Vulnerability):
        base = vuln.confidence or 0.4
        base = max(base, 0.35)

        if vuln.cve_id:
            base += 0.2
        if vuln.cvss_score:
            base += 0.1
        if vuln.tool_sources:
            base += min(len(vuln.tool_sources), 3) * 0.05

        severity_bonus = {
            'critical': 0.1,
            'high': 0.07,
            'medium': 0.04,
            'low': 0.02,
        }.get((vuln.severity or '').lower(), 0.0)
        base += severity_bonus

        vuln.confidence = round(min(base, 0.98), 2)

    def _correlate_vulnerabilities(self, vulns: List[Vulnerability]) -> List[Vulnerability]:
        aggregated: Dict[tuple, Vulnerability] = {}

        for vuln in vulns:
            key = (
                vuln.host,
                vuln.port,
                vuln.cve_id or vuln.title.lower(),
            )

            if key not in aggregated:
                aggregated[key] = vuln
                continue

            existing = aggregated[key]
            existing.tool_sources = sorted(set(existing.tool_sources + vuln.tool_sources))
            existing.references = list(dict.fromkeys(existing.references + vuln.references))
            existing.evidence = list(dict.fromkeys(existing.evidence + vuln.evidence))
            existing.attack_paths = list(dict.fromkeys(existing.attack_paths + vuln.attack_paths))
            existing.confidence = round(max(existing.confidence, vuln.confidence), 2)

            if not existing.cve_id and vuln.cve_id:
                existing.cve_id = vuln.cve_id
            if not existing.cvss_score and vuln.cvss_score:
                existing.cvss_score = vuln.cvss_score

            if self._severity_rank(vuln.severity) < self._severity_rank(existing.severity):
                existing.severity = vuln.severity
                existing.title = vuln.title
                existing.description = vuln.description

        return list(aggregated.values())

    def _severity_rank(self, severity: Optional[str]) -> int:
        order = {
            'critical': 0,
            'high': 1,
            'medium': 2,
            'low': 3,
            'info': 4,
        }
        return order.get((severity or '').lower(), 5)

    def _extract_json_array(self, text: str) -> Optional[List[Dict[str, Any]]]:
        if not text:
            return None

        start = text.find('[')
        end = text.rfind(']')
        if start == -1 or end == -1 or end <= start:
            return None

        candidate = text[start:end + 1]
        try:
            return json.loads(candidate)
        except json.JSONDecodeError:
            # Attempt to sanitize backticks or trailing commas
            sanitized = candidate.replace('```', '')
            try:
                return json.loads(sanitized)
            except json.JSONDecodeError:
                return None
    
    async def _ai_analyze_vulnerabilities(
        self,
        vulns: List[Vulnerability],
        scan_output: str
    ) -> List[Vulnerability]:
        """Use AI to provide deeper analysis and context"""
        
        try:
            # Prepare context for AI
            vuln_summary = "\n".join([
                f"- ID: {v.id} | {v.severity.upper()}: {v.title} ({v.description[:120]}...)"
                for v in vulns[:10]  # Limit to top 10 for token efficiency
            ])
            
            messages = [
                AIMessage(
                    role="system",
                    content="You are a cybersecurity expert analyzing vulnerability scan results. Provide actionable insights and prioritize findings."
                ),
                AIMessage(
                    role="user",
                    content=f"""Analyze these vulnerability findings:

{vuln_summary}

Raw scan output (excerpt):
{scan_output[:1000]}

For each listed finding return a JSON array where each object contains:
- id (matching the ID above)
- risk_level (critical/high/medium/low/info)
- confidence (0.0-1.0)
- exploit_available (true/false)
- remediation (short actionable string)
- evidence (array of key observations or log lines)
- attack_paths (array of potential exploitation paths)

Only return the JSON array, no additional text."""
                )
            ]
            
            # Get AI analysis
            response = await ai_manager.chat(messages=messages, temperature=0.3)
            
            ai_data = self._extract_json_array(response.content)

            if not ai_data:
                logger.info("AI response did not contain JSON payload; skipping enrichment")
                return vulns

            vuln_map = {v.id: v for v in vulns}

            for entry in ai_data:
                vuln = vuln_map.get(entry.get('id'))
                if not vuln:
                    continue

                if entry.get('remediation'):
                    vuln.remediation = entry['remediation']

                if 'exploit_available' in entry:
                    vuln.exploit_available = bool(entry['exploit_available'])

                if 'confidence' in entry:
                    try:
                        ai_conf = float(entry['confidence'])
                        vuln.confidence = round(max(vuln.confidence, ai_conf), 2)
                    except (TypeError, ValueError):
                        pass

                evidence = entry.get('evidence') or []
                if isinstance(evidence, list):
                    vuln.evidence = list(dict.fromkeys(vuln.evidence + evidence))

                attack_paths = entry.get('attack_paths') or []
                if isinstance(attack_paths, list):
                    vuln.attack_paths = list(dict.fromkeys(vuln.attack_paths + attack_paths))

                risk_level = entry.get('risk_level')
                if risk_level and self._severity_rank(risk_level) < self._severity_rank(vuln.severity):
                    vuln.severity = risk_level.lower()

                vuln.ai_annotations = entry
        
        except Exception as e:
            logger.error(f"AI analysis failed: {e}")
        
        return vulns
    
    def prioritize_vulnerabilities(self, vulns: List[Vulnerability]) -> List[Vulnerability]:
        """Prioritize vulnerabilities by severity and exploitability"""
        severity_order = {
            'critical': 0,
            'high': 1,
            'medium': 2,
            'low': 3,
            'info': 4,
        }
        
        return sorted(vulns, key=lambda v: (
            severity_order.get(v.severity, 99),
            -round(v.confidence or 0.0, 2),
            -1 if v.exploit_available else 0,
            -v.cvss_score if v.cvss_score else 0,
        ))
    
    async def generate_report(
        self,
        vulns: List[Vulnerability],
        format: str = "text"
    ) -> str:
        """Generate a vulnerability report"""
        
        if format == "text":
            lines = ["=" * 60, "VULNERABILITY REPORT", "=" * 60, ""]
            
            prioritized = self.prioritize_vulnerabilities(vulns)
            
            severity_counts = {}
            for v in prioritized:
                severity_counts[v.severity] = severity_counts.get(v.severity, 0) + 1
            
            lines.append("SUMMARY:")
            for severity in ['critical', 'high', 'medium', 'low', 'info']:
                count = severity_counts.get(severity, 0)
                if count > 0:
                    lines.append(f"  {severity.upper()}: {count}")
            lines.append("")
            
            lines.append("DETAILED FINDINGS:")
            lines.append("")
            
            for vuln in prioritized:
                lines.append(f"[{vuln.severity.upper()}] {vuln.title}")
                lines.append(f"  ID: {vuln.id}")
                if vuln.cve_id:
                    lines.append(f"  CVE: {vuln.cve_id}")
                if vuln.cvss_score:
                    lines.append(f"  CVSS: {vuln.cvss_score}")
                lines.append(f"  Confidence: {vuln.confidence:.2f}")
                if vuln.tool_sources:
                    lines.append(f"  Sources: {', '.join(vuln.tool_sources)}")
                lines.append(f"  Description: {vuln.description}")
                if vuln.remediation:
                    lines.append(f"  Remediation: {vuln.remediation}")
                if vuln.evidence:
                    lines.append(f"  Evidence: {vuln.evidence[0]}")
                if vuln.attack_paths:
                    lines.append(f"  Attack Paths: {', '.join(vuln.attack_paths)}")
                lines.append("")
            
            return "\n".join(lines)
        
        elif format == "json":
            import json
            return json.dumps([{
                'id': v.id,
                'title': v.title,
                'description': v.description,
                'severity': v.severity,
                'cvss_score': v.cvss_score,
                'cve_id': v.cve_id,
                'host': v.host,
                'port': v.port,
                'remediation': v.remediation,
                'exploit_available': v.exploit_available,
                'references': v.references,
                'confidence': v.confidence,
                'evidence': v.evidence,
                'attack_paths': v.attack_paths,
                'tool_sources': v.tool_sources,
                'ai_annotations': v.ai_annotations,
            } for v in vulns], indent=2)
        
        else:
            raise ValueError(f"Unsupported format: {format}")

